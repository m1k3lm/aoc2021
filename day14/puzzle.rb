class Puzzle

    def initialize(filename)
        inputs = File.open(filename, "r").readlines.map { |line| line.chomp }
        @current_step = 0
        @chain_at_step = []
        @rules = {}
        @memo = {}
        @chain_at_step[0] = inputs.shift.chars
        inputs.shift
        inputs.each do |line|
            rule = line.split(" -> ")
            @rules[rule[0]] = rule[1]
        end
    end

    ##########BRUTE FORCE NOT VALID FOR LARGE NUMBERS OF STEPS############
    def next_step
        @current_step += 1
        chain_at_previus_step = @chain_at_step[@current_step - 1]
        @chain_at_step[@current_step] = []
        chain_at_previus_step.each_with_index do |char, i|
            pair = chain_at_previus_step[i] + (!chain_at_previus_step[i+1].nil? ? chain_at_previus_step[i+1] : "")
            @chain_at_step[@current_step] << chain_at_previus_step[i]
            @chain_at_step[@current_step] << @rules[pair] if @rules.key?(pair)
        end
    end

    def run_steps(steps)
        steps.times do
            next_step
        end
    end
    ###########################################################################

    def run_cicles(steps)
        char_fequencies = {}
        template_to_process = @chain_at_step[0].dup
        until template_to_process.length == 1 do # Loop chain taking overlaping pairs of chars.
            c1 = template_to_process.shift
            c2 = template_to_process.first
            char_fequencies[c1] ||= 0
            char_fequencies[c1] += 1
            char_fequencies.merge!(make_cicles(c1,c2,steps)){|k,v1,v2| v1+v2}
        end
        c1 = template_to_process.shift
        char_fequencies[c1] ||= 0
        char_fequencies[c1] += 1
        return char_fequencies.max_by { |k,v| v }[1] - char_fequencies.min_by { |k,v| v }[1]
    end

    def make_cicles(c1,c2,steps)
        t = c1+c2+steps.to_s # Unique tag to cache this value.
        return @memo[t] if @memo.key?(t)
        @memo[t] = {}
        c = @rules[c1+c2]; # Character generated by the rule.
        if steps > 0
            @memo[t] =
                make_cicles(c1,c,steps-1).
                merge(make_cicles(c,c2,steps-1)){|k,v1,v2| v1+v2}
            @memo[t][c] ||= 0
            @memo[t][c] += 1
        end
        return @memo[t]
    end

    def solve_part1
        # run_steps(10)
        # qtys = @chain_at_step[10].tally
        # return qtys.max_by { |k,v| v }[1] - qtys.min_by { |k,v| v }[1]
        return run_cicles(10)
    end

    def solve_part2
        return run_cicles(40)
    end
end